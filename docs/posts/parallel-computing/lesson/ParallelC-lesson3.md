---
title: 并行计算第三课-前置知识
date: 2025-10-23
author: 离谱纪-Waver
---

# 计算Prefix Sum
计算prefix sum（前缀和）确实看起来是串行的，但实际上可以通过巧妙的算法设计实现并行化！主要有几种经典的并行算法：

## 1. **Hillis-Steele算法（上扫-下扫）**

这是最直观的并行算法。基本思想是：
- 每一轮中，每个元素同时加上距离为2^k的前面元素
- 需要log(n)轮迭代

例如数组 [1, 2, 3, 4, 5, 6, 7, 8]：
```
初始:    1  2  3  4  5  6  7  8
轮1(+1): 1  3  5  7  9  11 13 15  (每个加前1个)
轮2(+2): 1  3  8  12 16 20 24 28 (每个加前2个)
轮3(+4): 1  3  8  14 24 32 40 44 (每个加前4个)
```

时间复杂度：O(log n)，但需要O(n log n)次操作（work-inefficient）

## 2. **Blelloch扫描算法**（更高效）

分为两个阶段：
- **Up-sweep（归约阶段）**：从叶子到根，构建部分和的树
- **Down-sweep（分发阶段）**：从根到叶子，计算最终的前缀和

这个算法是work-efficient的，总操作数O(n)，深度O(log n)。

## 3. **分块并行**

将数组分成k块：
1. 每个处理器并行计算自己块内的前缀和
2. 收集每块的总和，串行或递归地计算块间的前缀和
3. 将块间的偏移量加到各块内部

这在实际GPU编程（CUDA/OpenCL）中很常用！

## 核心洞察

并行化的关键是认识到：
- **依赖关系可以分层处理**：不需要严格从左到右
- **可以先并行计算局部信息，再合并**
- **树状结构可以将O(n)的串行依赖降到O(log n)的深度**

你想看具体哪种算法的代码实现吗？我可以用Python或其他语言展示。