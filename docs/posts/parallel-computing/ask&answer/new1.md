# 对比两种方案
---

## 硬件背景

- **Cube 核心**：128×128×128 矩阵乘单元，速度很快
- **Vec 核心**：2个，处理 softmax 和 rescale
- **L1A/L1B**：各 64KB，能装 512×128 的 FP16 矩阵
- **L2**：192MB，20组核心共享
- **问题规模**：Q, K, V 都是 8192×128

---

## 方案概述

### 完整行方案

Q[i][a]（128×128）固定，K[1]...K[16] 全部扫描完，得到完整的 128×8192 行，一次性做 softmax，再做 PV。

### Online 方案（优化后）

Q[i][a]（128×128）固定，每次处理一个 K[j]（512×128），得到 128×512 的块，做 partial softmax 后立即做 PV，然后 rescale 累积结果。

---

## 单行块（Q[1][1]）详细计算流程

### 完整行方案

| 阶段 | 操作 | 计算量 | L2 写 | L2 读 |
|------|------|--------|-------|-------|
| QK | Q[1][1] × K[1...16] | 64次矩阵乘 | 4MB (FP32) | - |
| Softmax | 完整 128×8192 | - | 2MB (FP16) | 4MB |
| PV | P × V[1...16] | 64次矩阵乘 | 64KB (FP32) | 2MB |

**总计**：
- 矩阵乘：128次
- L2 写：6.06MB
- L2 读：6MB
- L2 总传输：12.06MB

### Online 方案（优化后）

对于每个 K[j]（j = 1 到 16）：

| 阶段 | 操作 | 计算量 | L2 写 | L2 读 |
|------|------|--------|-------|-------|
| QK | Q[1][1] × K[j] | 4次矩阵乘 | 256KB (FP32) | - |
| Softmax | 128×512 partial | - | 128KB (FP16) | 256KB |
| PV | P × V[j] | 4次矩阵乘 | 64KB (FP32) | 128KB |
| Rescale | 更新累积 O | - | 64KB | 64KB |

**单个 K[j] 小计**：
- 矩阵乘：8次
- L2 写：512KB
- L2 读：448KB

**16轮总计**：
- 矩阵乘：128次
- L2 写：8MB
- L2 读：7.2MB
- Rescale 额外读写：64KB × 15 × 2 = 1.9MB
- L2 总传输：17.1MB

---

## 关键指标对比

### 1. 计算量

| 指标 | 完整行方案 | Online 方案 |
|------|------------|-------------|
| QK 矩阵乘 | 64次 | 64次 |
| PV 矩阵乘 | 64次 | 64次 |
| **总矩阵乘** | **128次** | **128次** |
| Rescale 计算 | 0 | 15次 |

**结论**：矩阵乘次数相同，但 Online 方案额外有 15 次 rescale。

### 2. L2 数据传输

| 指标 | 完整行方案 | Online 方案 | 差异 |
|------|------------|-------------|------|
| L2 写入 | 6.06MB | 9.9MB | +63% |
| L2 读取 | 6MB | 7.2MB | +20% |
| **总传输** | **12.06MB** | **17.1MB** | **+42%** |

### 3. L2 读写次数

| 操作 | 完整行方案 | Online 方案 |
|------|------------|-------------|
| QK 结果写 | 1次 (4MB) | 16次 (256KB×16) |
| Softmax 读 | 64次 (64KB×64) | 128次 (32KB×128) |
| Softmax 写 | 64次 (32KB×64) | 128次 (16KB×128) |
| PV 输入读 | 64次 (32KB×64) | 128次 (16KB×128) |
| PV 结果写 | 1次 (64KB) | 16次 (64KB×16) |
| Rescale 读写 | 0 | 30次 (64KB×30) |
| **总次数** | **~194次** | **~446次** | **+130%** |

### 4. 同步开销

| 指标 | 完整行方案 | Online 方案 | 差异 |
|------|------------|-------------|------|
| Cube→Vec 同步 | 1次 | 16次 | 16× |
| Vec→Cube 同步 | 1次 | 16次 | 16× |
| **总同步点** | **2次** | **32次** | **16×** |

### 5. L2 峰值占用

| 指标 | 完整行方案 | Online 方案 |
|------|------------|-------------|
| S 矩阵 | 4MB | 256KB |
| P 矩阵 | 2MB | 128KB |
| O 累积 | - | 64KB |
| **峰值** | **~6MB** | **~448KB** |

---

## 流水线效率分析

### 完整行方案时序

```
时间 →
Cube:  [========QK(64次)========][idle][========PV(64次)========]
Vec:                             [====Softmax====]

下一行块：
Cube:  [========QK========][idle][========PV========]
Vec:                       [====Softmax====]
```

**特点**：
- Cube 连续执行 64 次，无中断
- 只有 2 个同步点
- Vec 处理大块数据，内部可优化

### Online 方案时序

```
时间 →
K[1]:  [QK×4][wait][SM][wait][PV×4][wait][RS]
K[2]:  [QK×4][wait][SM][wait][PV×4][wait][RS]
...
K[16]: [QK×4][wait][SM][wait][PV×4][wait][RS]
```

**特点**：
- 每个 K[j] 内部有多次等待
- 16轮串行依赖
- Cube 频繁空闲

### 利用率估算

假设：
- 单次矩阵乘：T_cube
- 单次同步等待：T_sync
- Vec 处理 128×512：T_vec_small
- Vec 处理 128×8192：T_vec_full

**完整行方案**：
```
总时间 ≈ 64×T_cube + T_sync + T_vec_full + T_sync + 64×T_cube
       = 128×T_cube + 2×T_sync + T_vec_full
```

**Online 方案**：
```
单轮 = 4×T_cube + T_sync + T_vec_small + T_sync + 4×T_cube + T_sync + T_rescale
     = 8×T_cube + 3×T_sync + T_vec_small + T_rescale

总时间 = 16 × 单轮
       = 128×T_cube + 48×T_sync + 16×T_vec_small + 16×T_rescale
```

**关键差异**：
- 同步开销：2×T_sync vs 48×T_sync（**24倍**）
- Vec 开销：T_vec_full vs 16×T_vec_small + 16×T_rescale

---

## 多核并行扩展

### 完整行方案

20组核心独立处理不同行块：
```
核心0:  Q[1][1] 完整流程
核心1:  Q[1][2] 完整流程
...
核心19: Q[5][4] 完整流程
```

- 各核心完全独立
- L2 带宽是唯一共享瓶颈
- 负载均衡简单

### Online 方案

同样可以并行，但：
- 每个核心内部效率低
- 更多 L2 访问导致带宽竞争更激烈
- 同步开销在核心内部累积

---

## 数值稳定性

### 完整行方案

```python
# 一次性计算
max_val = max(S[i, :])  # 全局最大值
exp_S = exp(S[i, :] - max_val)
softmax = exp_S / sum(exp_S)
```

- 直接得到正确结果
- 无累积误差
- 实现简单

### Online 方案

```python
# 迭代更新
for j in range(16):
    local_max = max(S_block[j])
    if local_max > global_max:
        # rescale 之前所有结果
        scale = exp(global_max - local_max)
        O_accum *= scale
        sum_exp *= scale
        global_max = local_max
    # 累加当前块
    O_accum += ...
```

- 需要跟踪全局 max
- 每次可能需要 rescale
- 浮点误差累积（15次 rescale）
- 实现复杂

---

## 实现复杂度

### 完整行方案

```
数据流：Q[i][a] → K全扫描 → S完整行 → Softmax → P → V全扫描 → O
状态：无需维护中间状态
控制：简单的两阶段流水
```

### Online 方案

```
数据流：Q[i][a] → K[j] → S块 → Partial Softmax → P块 → V[j] → O块 → Rescale → 累积
状态：需要维护 global_max, sum_exp, O_accum
控制：复杂的多阶段同步，条件分支（是否需要 rescale）
```

---

## 适用场景分析

### 完整行方案适合

1. **L2 容量充足**：192MB >> 6MB 峰值占用
2. **Cube 速度快**：同步开销占比更显著
3. **追求高吞吐**：减少同步，最大化 Cube 利用率
4. **数值精度要求高**：无累积误差

### Online 方案适合

1. **L2 容量受限**：只有几 MB 可用
2. **序列长度极长**：完整行放不下（如 seq_len = 128K）
3. **需要流式输出**：边算边用
4. **内存带宽是主要瓶颈**：减少峰值带宽需求

---

## 昇腾硬件上的结论

| 维度 | 完整行方案 | Online 方案 | 胜者 |
|------|------------|-------------|------|
| L2 传输总量 | 12.06MB | 17.1MB | 完整行 **(-30%)** |
| L2 读写次数 | 194次 | 446次 | 完整行 **(-57%)** |
| 同步开销 | 2次 | 32次 | 完整行 **(-94%)** |
| Cube 利用率 | 高 | 低 | 完整行 |
| Vec 利用率 | 高 | 中 | 完整行 |
| 数值稳定性 | 完美 | 有累积误差 | 完整行 |
| 实现复杂度 | 简单 | 复杂 | 完整行 |
| L2 峰值占用 | 6MB | 448KB | Online |
| 流式输出 | 不支持 | 支持 | Online |

---

## 最终结论

**在昇腾这种架构上，完整行方案是明显更优的选择**：

1. **L2 容量不是瓶颈**：192MB 足够容纳多个行块的中间结果
2. **Cube 速度快**：同步开销的相对占比更大，Online 方案 32 次同步 vs 2 次是致命劣势
3. **L2 访问次数**：446 次 vs 194 次，每次都有固定开销
4. **L2 传输量**：17.1MB vs 12.06MB，多 42% 的带宽消耗

Online 方案唯一的优势（低峰值内存）在昇腾上**完全不重要**，而它的所有劣势（同步开销、读写次数、rescale 计算、实现复杂度）都会**实实在在地拖慢性能**。

**推荐**：在昇腾设备上使用完整行方案，除非序列长度极端长（远超 8192）导致单行真的放不进 L2。